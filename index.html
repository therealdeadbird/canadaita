<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Histogram</title>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.min.js"></script>
    <style type="text/css">
body {
    margin: 3em;
}

line {
    stroke: #ccc;
    stroke-width: 1px;
}
circle {
    fill: steelblue;
}
.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}
    </style>
  </head>
  <body>
<div id="parameters">
</div>


    <script type="text/javascript">
// Create parameter range sliders
paramConfigs= [
  { name: 'muLow', min: 0, max: 600, value: 420 },
  { name: 'sigmaLow', min: 30, max: 100, value: 50 },
  { name: 'muHigh', min: 600, max: 1200, value: 1000 },
  { name: 'sigmaHigh', min: 30, max: 100, value: 50 },
  { name: 'delay', min: 0, max: 1000, value: 10 },
  { name: 'numNewLow', min: 0, max: 2000, value: 1000 },
  { name: 'numNewHigh', min: 0, max: 2000, value: 1000 },
  { name: 'numITA', min: 0, max: 5000, value: 800 },
];

var parameters = d3.select('#parameters')
    .selectAll('p')
    .data(paramConfigs)
    .enter()
    .append('p');
            
parameters.append('label')
          .attr('for', function(d) {return 'range-' + d.name;})
          .style('display', 'inline-block')
          .style('width', '240px')
          .style('text-align', 'right')
          .style('font-size', '12px')
          .style('font-weight', 'bold')
          .text(function(d) { return d.name + ' = ' + d.value; });

parameters.append('input')
          .attr('type', 'range')
          .attr('min', function(d) { return d.min; })
          .attr('max', function(d) { return d.max; })
          .attr('id', function(d) { return 'range-' + d.name; })
          .attr('value', function(d) { return d.value; });

parameters.on('change', function() {
  var value = d3.select(this).select('input').property('value');
  var label = d3.select(this).select('label');
  label.text(function(d) { return d.name + ' = ' + value; });
});

// data generator
var minScore = 0,
    maxScore = 1200,
    binWidth = 5,
    numNewLow = 1000,
    numNewHigh = 1000,
    bins = (maxScore - minScore) / binWidth,
    numParallelSample = 5, // number of points to sample in parallel
    gaussianLow = null,
    gaussianHigh = null;

var updateGaussians = function() {
    var gaussianLowMu = +d3.select('#range-muLow').property('value');
    var gaussianLowSigma = +d3.select('#range-sigmaLow').property('value');
    var gaussianHighMu = +d3.select('#range-muHigh').property('value');
    var gaussianHighSigma = +d3.select('#range-sigmaHigh').property('value');
    var clamp = function(gen) {
      return function() {
        return ~~Math.max(minScore, Math.min(gen(), maxScore));
      };
    }
    gaussianLow = clamp(d3.random.normal(gaussianLowMu, gaussianLowSigma));
    gaussianHigh = clamp(d3.random.normal(gaussianHighMu, gaussianHighSigma));
}
updateGaussians();

var data = d3.range(bins).map(function() { return [] });

generator = function() {
    return Math.random() > (numNewLow/(numNewLow + numNewHigh))  ? 
        gaussianLow() : gaussianHigh();
};

var delay = 10,
    exitDelay = 500,
    w = 600,
    h = 400,
    binWidth = w/bins,
    radius = 1.5,
    padding = 0;
    chartPadding = 30;
    
var xScale = d3.scale.linear()
            .domain([minScore, maxScore])
            .range([minScore, w]);

var yScale = d3.scale.linear()
            .domain([0, h])
            .range([h, 0]);

var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient('bottom');

var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient('left');
// chart
var chart = d3.select('body').append('svg:svg')
    .attr('width', w + chartPadding * 2)
    .attr('height', h + chartPadding * 2)
  .append('svg:g')
    .attr('transform', 'translate(' + chartPadding +
         ',' + chartPadding + ')');
    
xAxisElement = chart.append('g')
    .attr('class', 'axis')
    .attr('transform', 'translate(0,' + h +')')
    .call(xAxis);

yAxisElement = chart.append('g')
    .attr('class', 'axis')
    .attr('transform', 'translate(0, 0)')
    .call(yAxis);


// bottom line
chart.append('svg:line')
    .attr('x1', 0)
    .attr('x2', w)
    .attr('y1', h)
    .attr('y2', h);

// middle line
chart.append('svg:line')
    .attr('x1', xScale(maxScore/2))
    .attr('x2', xScale(maxScore/2))
    .attr('y1', 0)
    .attr('y2', h);
    
var binCols = chart.selectAll('g.bin')
    .data(data)
  .enter().append('svg:g')
    .attr('class', 'bin')
    .attr('transform', function(d,i) { return 'translate(' + (i * binWidth) + ',0)' });
    
function redraw() {
    var dots = binCols.selectAll('circle')
        .data(function(d) { return d });
        
    dots.enter().append('svg:circle')
        .attr('cx', binWidth/2)
        .attr('cy', 0)
        .attr('r', radius);
        
    dots.transition()
        .duration(delay)
        .ease('bounce')
        .attr('cy', function(d,i) {
            return h - (i * (radius*2 + padding) + padding*2) 
        });

    dots.exit()
        .transition()
        .duration(exitDelay)
        .each('start', function() {
            d3.select(this)
                .style('color', 'red');
        })
        .attr('cy', h + chartPadding)
        .remove();
}

var target = numNewLow + numNewHigh,
    counter = 0,
    intervalId = setInterval(function() {
        for(var i=0 ; i < numParallelSample && counter <= target; i++) {
            var number = generator();
            // console.log(number);
            bin = ~~(number / maxScore * bins);
            data[bin].push(number);
            counter++;
        }
        redraw();
        if (counter > target) {
            clearInterval(intervalId);
        }
    }, delay);
    
    </script>
  </body>
</html>
