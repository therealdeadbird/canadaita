<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Histogram</title>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.min.js"></script>
    <style type="text/css">
body {
    margin: 3em;
}

line {
    stroke: #ccc;
    stroke-width: 1px;
}
circle {
    fill: steelblue;
}
.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}
.cutoff-label {
    font-size: 12px;
    font-weight: bold;
    text-align: center;
}
#main-options button {
  color: #fff;
  background-color: #6496c8;
  border: none;
  border-radius: 15px;
  padding: 10px;;
  box-shadow: 0 3px #27496d;
}

#main-options button:hover,
#main-options button.hover {
  background-color: #417cb8
}

#main-options button:active,
#main-options button.active {
  background-color: #417cb8;
  box-shadow: 0 5px #27496d;
  transform: translateY(2px);
}

    </style>
  </head>
  <body>
<div id="parameters">
</div>
<div id="main-options">
    <button id="drawButton" title="New Draw" onclick="makeDraw()">
        New Draw
    </button>
</div>


    <script type="text/javascript">
// Create parameter range sliders
paramConfigs= [
  { name: 'numInitialCandidates', min: 100, max: 50000, value: 10000 },
  { name: 'muLow', min: 0, max: 600, value: 420 },
  { name: 'sigmaLow', min: 30, max: 100, value: 1000 },
  { name: 'muHigh', min: 600, max: 1200, value: 1000 },
  { name: 'sigmaHigh', min: 30, max: 100, value: 100 },
  { name: 'delay', min: 0, max: 1000, value: 10 },
  { name: 'numNewLow', min: 0, max: 2000, value: 1000 },
  { name: 'numNewHigh', min: 0, max: 2000, value: 1000 },
  { name: 'numITA', min: 0, max: 5000, value: 800 },
];

var parameters = d3.select('#parameters')
    .selectAll('p')
    .data(paramConfigs)
    .enter()
    .append('p');
            
parameters.append('label')
          .attr('for', function(d) {return 'range-' + d.name;})
          .style('display', 'inline-block')
          .style('width', '240px')
          .style('text-align', 'right')
          .style('font-size', '12px')
          .style('font-weight', 'bold')
          .text(function(d) { return d.name + ' = ' + d.value; });

parameters.append('input')
          .attr('type', 'range')
          .attr('min', function(d) { return d.min; })
          .attr('max', function(d) { return d.max; })
          .attr('id', function(d) { return 'range-' + d.name; })
          .attr('value', function(d) { return d.value; });

parameters.on('change', function() {
  var value = d3.select(this).select('input').property('value');
  var label = d3.select(this).select('label');
  label.text(function(d) { return d.name + ' = ' + value; });
});

// data generator
var minScore = 0,
    maxScore = 1200,
    numNewLow = 200,
    numNewHigh = 200,
    numITA = 200,
    numInitialCandidates = 3000,
    cutoffITA = 483,
    bins = 240,
    numParallelSample = 5, // number of points to sample in parallel
    gaussianLow = null,
    gaussianHigh = null;

var updateGaussians = function() {
    var gaussianLowMu = +d3.select('#range-muLow').property('value');
    var gaussianLowSigma = +d3.select('#range-sigmaLow').property('value');
    var gaussianHighMu = +d3.select('#range-muHigh').property('value');
    var gaussianHighSigma = +d3.select('#range-sigmaHigh').property('value');
    var clamp = function(gen) {
      return function() {
        return ~~Math.max(minScore, Math.min(gen(), maxScore - 1e-10));
      };
    }
    gaussianLow = clamp(d3.random.normal(gaussianLowMu, gaussianLowSigma));
    gaussianHigh = clamp(d3.random.normal(gaussianHighMu, gaussianHighSigma));
}
updateGaussians();

var data = d3.range(bins).map(function() { return [] });

generator = function() {
    return Math.random() > (numNewLow/(numNewLow + numNewHigh))  ? 
        gaussianLow() : gaussianHigh();
};

var delay = 100,
    exitDelay = 1000,
    w = 800,
    h = 600,
    binWidth = w/bins,
    radius = 1.5,
    padding = 0;
    chartPadding = 30;
    
var xScale = d3.scale.linear()
            .domain([minScore, maxScore])
            .range([minScore, w]);

var yScale = d3.scale.linear()
            .domain([0, h])
            .range([h, 0]);

var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient('bottom');

var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient('left');
// chart
var chart = d3.select('body').append('svg:svg')
    .attr('width', w + chartPadding * 2)
    .attr('height', h + chartPadding * 2)
  .append('svg:g')
    .attr('transform', 'translate(' + chartPadding +
         ',' + chartPadding + ')');
    
xAxisElement = chart.append('g')
    .attr('class', 'axis')
    .attr('transform', 'translate(0,' + h +')')
    .call(xAxis);

yAxisElement = chart.append('g')
    .attr('class', 'axis')
    .attr('transform', 'translate(0, 0)')
    .call(yAxis);


// bottom line
chart.append('svg:line')
    .attr('x1', 0)
    .attr('x2', w)
    .attr('y1', h)
    .attr('y2', h);

// previous cutoff
var cutoffLine = chart.append('svg:line')
    .attr('x1', xScale(cutoffITA))
    .attr('x2', xScale(cutoffITA))
    .attr('y1', 0)
    .attr('y2', h);

var cutoffLabel = chart.append('text')
    .attr('class', 'cutoff-label')
    .attr('transform', 'translate(' + xScale( cutoffITA + 5 ) + ',10)')
    .text('cutoff: ' + cutoffITA);
    
var binCols = chart.selectAll('g.bin')
    .data(data)
  .enter().append('svg:g')
    .attr('class', 'bin')
    .attr('transform', function(d,i) { return 'translate(' + (i * binWidth) + ',0)' });
    
function redraw() {
    var dots = binCols.selectAll('circle')
        .data(function(d) { return d });
        
    var newdots = dots.enter().append('svg:circle')
        .attr('cx', binWidth/2)
        .attr('cy', 0)
        .attr('r', radius);
        
    newdots.transition()
        .duration(delay)
        .each('start', function() {
            d3.select(this)
                .style('fill', 'purple');
        })
        .attr('cy', function(d,i) {
            return h - (i * (radius*2 + padding) + padding*2) 
        })
        .each('end', function() {
            d3.select(this)
                .transition()
                .delay(1000)
                .style('fill', 'steelblue');
        });
}

var removeCircles = function() {
    var dots = binCols.selectAll('circle')
        .data(function(d) { return d });
    dots.exit()
        .transition()
        .duration(exitDelay)
        .each('start', function() {
            d3.select(this)
                .style('fill', 'red');
        })
        .attr('cy', h + chartPadding)
        .remove();
}

var updateITACutoffLine = function() {
    cutoffLine.transition()
        .duration(exitDelay)
        .attr('x1', xScale(cutoffITA))
        .attr('x2', xScale(cutoffITA));

    cutoffLabel.transition()
        .duration(exitDelay)
        .attr('transform', 'translate(' + xScale( cutoffITA + 5 ) + ',10)')
        .text('cutoff: ' + cutoffITA);
};

// Select Candidates
var removeSelectedCandidates = function() {
    var numSelected = 0
        binIdx = 0;
    for(var binIdx=data.length - 1 ; numSelected < numITA && binIdx >= 0 ; binIdx--) {
        while(numSelected < numITA && data[binIdx].length > 0) {
            data[binIdx].shift();
            numSelected++;
        }
    }
    cutoffITA = binIdx * maxScore / bins;
    updateITACutoffLine();
    removeCircles();
}

var addNewCandidates = function() {
    // Add potential candidates
    var numNewCandidates = numNewLow + numNewHigh,
        counter = 0,
        intervalId = setInterval(function() {
            for(var i=0 ; i < numParallelSample && counter <= numNewCandidates; i++) {
                var crsScore = generator();
                bin = ~~(crsScore / maxScore * bins);
                if(bin > 239) {
                    console.log('wtF!!');
                }
                data[bin].push(crsScore);
                counter++;
            }
            redraw();
            if (counter > numNewCandidates) {
                clearInterval(intervalId);
                setTimeout(removeSelectedCandidates, exitDelay);
            }
        }, delay);
}

// Add initial candidates
var numInitial = 0;
while(numInitial < numInitialCandidates) {
    var crsScore = generator();
    // Perform rejection sampling
    if (crsScore >= cutoffITA) continue;
    bin = ~~(crsScore / maxScore * bins);
    data[bin].push(crsScore);
    numInitial++;
}
console.log(numInitial)
redraw();

window.makeDraw = function() {
    addNewCandidates();
};


    </script>
  </body>
</html>
